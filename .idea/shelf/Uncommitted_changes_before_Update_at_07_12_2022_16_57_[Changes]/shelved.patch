Index: src/match/players/PlayerDecisionEvent.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>export const DECISION = {\r\n    MOVE: 'move',\r\n    PASS: 'pass',\r\n    SHOT: 'shot',\r\n};\r\n\r\nexport default class PlayerDecisionEvent {\r\n    constructor(player, homeTeam, awayTeam) {\r\n        this.player = player;\r\n        this.awayTeam = awayTeam;\r\n        this.homeTeam = homeTeam;\r\n        //       this.maxIndex = 100;\r\n    }\r\n\r\n    //diagnostic functionality\r\n    // validator() {\r\n    //     let possibilitySum = this.getPossibilityOfMove() + this.getPossibilityOfPass() + this.getPossibilityOfShoot();\r\n    //     if (possibilitySum !== this.maxIndex) {\r\n    //         alert('Sum of possibility not equal to max possibility !');\r\n    //     }\r\n    // }\r\n\r\n    run() {\r\n        const {moveRange, passRange, shootRange} = this.createRanges();\r\n        const randomIndex = Math.round(Math.random() * shootRange.max);\r\n\r\n        if (randomIndex >= moveRange.min && randomIndex <= moveRange.max) {\r\n            return DECISION.MOVE;\r\n        }\r\n        if (randomIndex > passRange.min && randomIndex <= passRange.max) {\r\n            return DECISION.PASS;\r\n        }\r\n        if (randomIndex > shootRange.min && randomIndex <= shootRange.max) {\r\n            return DECISION.SHOT;\r\n        }\r\n    }\r\n\r\n    createRanges() {\r\n        const moveRange = {\r\n            min: 0,\r\n            max: this.getPossibilityOfMove()\r\n        };\r\n        const passRange = {\r\n            min: moveRange.max,\r\n            max: moveRange.max + this.getPossibilityOfPass()\r\n        };\r\n        const shootRange = {\r\n            min: passRange.max,\r\n            max: passRange.max + this.getPossibilityOfShoot()\r\n        }\r\n        return {moveRange, passRange, shootRange};\r\n    }\r\n\r\n    getPossibilityOfMove() {\r\n        if (this.player.hasBall) {\r\n            if (this.player.isInAwayTeam) {\r\n                return this.getBestRunningDestination(this.homeTeam);\r\n            } else {\r\n                return this.getBestRunningDestination(this.awayTeam)\r\n            }\r\n        } else\r\n            return 10;\r\n    }\r\n\r\n\r\n    getBestRunningDestination(oppositePlayers) {\r\n        const goalCenterCoordinates = {\r\n            positionX: 0,\r\n            positionY: 0\r\n        };\r\n        if (this.player.isInAwayTeam) {\r\n            goalCenterCoordinates.positionX = this.player.field.homeGoalX;\r\n            goalCenterCoordinates.positionY = this.player.field.homeGoalY + this.player.field.goalHeight / 2;\r\n        } else {\r\n            goalCenterCoordinates.positionX = this.player.field.awayGoalX;\r\n            goalCenterCoordinates.positionY = this.player.field.awayGoalY + this.player.field.goalHeight / 2;\r\n        }\r\n\r\n        let bestTunnelValue = 0;\r\n        let r = this.player.getDistanceTo(goalCenterCoordinates);\r\n\r\n        let runningDestinations = this.getRunningDestinations(this.player, goalCenterCoordinates, r);\r\n\r\n        runningDestinations.forEach((destination) => {\r\n            if (bestTunnelValue < this.getTunnelValue(oppositePlayers, destination)) {\r\n                bestTunnelValue = this.getTunnelValue(oppositePlayers, destination);\r\n                this.player.destinationX = destination.positionX;\r\n                this.player.destinationY = destination.positionY;\r\n\r\n            }\r\n        });\r\n\r\n        return bestTunnelValue;\r\n    }\r\n\r\n\r\n    getDistanceFromTo(object1, object2) {\r\n        let deltaX = object1.positionX - object2.positionX;\r\n        let deltaY = object1.positionY - object2.positionY;\r\n        // if (deltaX + deltaY < 1) {\r\n        //     return 0;\r\n        // }\r\n        return Math.ceil(Math.sqrt(deltaX * deltaX + deltaY * deltaY));\r\n    }\r\n\r\n    getRunningDestinations(player, destination, r) {\r\n        let runningDestinations = [];\r\n        const thirdTrianglePoint = {   // opisanie trójkąta gracz-cel-ośY bokami a b c   \\/\r\n            positionX: player.positionX + r,\r\n            positionY: player.positionY\r\n        };\r\n        let a = r;\r\n        let b = r;\r\n        let c = this.getDistanceFromTo(destination, thirdTrianglePoint);\r\n\r\n        let angle = Math.round(this.convertToDegrees(Math.acos((a * a + b * b - c * c) / (2 * a * b))));    // wyliczenie kąta między a i b\r\n        let originalAngle = angle;    // zapisujemy oryginalny kąt między celem a osią Y, aby później użyć go w ocenie atrakcyjności kanału\r\n        let isBelowTarget = 1;\r\n        if (player.positionY > destination.positionY) {     // zmienna nadająca znak + lub - odchyleniu celu biegu na osi Y wyliczanemu z funkcji sin poniżej\r\n            isBelowTarget = -1;\r\n        }\r\n\r\n        for (let i = 0; i < 18; i++) {    // wyznaczenie 18 kierunków biegu\r\n            runningDestinations[i] = {\r\n                positionX: Math.round(player.positionX + r * Math.cos(this.convertToRadians(angle))),\r\n                positionY: Math.round(player.positionY + r * isBelowTarget * Math.sin(this.convertToRadians(angle))),\r\n                angle: angle,\r\n                originalAngle: originalAngle\r\n            };\r\n            if (angle > 340) {\r\n                angle = angle - 340;\r\n            }\r\n            angle = angle + 20;      // zwiększenie kąta o 1/18 okręgu, tj 20 stopni\r\n        }\r\n        return runningDestinations;\r\n    }\r\n\r\n    convertToRadians(angle) {\r\n        return (angle * Math.PI / 180)\r\n    }\r\n\r\n    convertToDegrees(radians) {\r\n        return (radians * 180 / Math.PI);\r\n    }\r\n\r\n    getTunnelValue(oppositePlayers, destination) {\r\n        let tunnelLength = 150; // TODO - ustalić długość tunelu w zależności od skilla zawodnika\r\n        let opponentDistance = 75; // poniżej tej wartości odległość przeciwnika od tunelu wpływa na jego ocenę\r\n\r\n        let a = this.getDistanceFromTo(this.player, destination); // boki trójkąta gracz - cel\r\n        let b = 0;                                                // gracz - przeciwnik\r\n        let c = 0;                                                // cel - przeciwnik\r\n        let tunnelValue = 100;\r\n\r\n        destination.angle = destination.angle - destination.originalAngle;\r\n        if (destination.angle > 180) {\r\n            destination.angle = 360 - destination.angle;\r\n        }\r\n        tunnelValue = tunnelValue - Math.abs(destination.angle / 2);     // odjęcie od atrakcyjności tunelu połowy odchylenia od celu w stopniach\r\n                                                                            // np odchylenie 0 ->   atracyjność 100\r\n                                                                            // odchylenie 90 ->     atrakcyjność 100 - 90/2 = 55\r\n                                                                            // odchylenie 180 ->    atrakcyjność 100 - 180/2 = 10\r\n\r\n        let halfOfTrianglePerimeter = 0;            // zmienne potrzebne do wyliczenia wysokości trójkąta gracz - przeciwnik - cel\r\n        let triangleField = 0;\r\n        let triangleHeight = 50;\r\n\r\n        oppositePlayers.forEach((oppositePlayer) => {\r\n            b = this.player.getDistanceTo(oppositePlayer);\r\n            c = this.getDistanceFromTo(oppositePlayer, destination);\r\n            if (b < a && c < a) {                                       // nie bierzemy pod uwagę przeciwników umiejscowionych dalej od gracza i celu, niż gracz i cel są oddaleni od siebie\r\n                if (b < tunnelLength) {                                 // ograniczenie długości tunelu TODO podzielić tunel i dodać ważone oceny w zależności od odłegłości od gracza\r\n                    halfOfTrianglePerimeter = (a + b + c) / 2;\r\n                    triangleField = Math.sqrt(halfOfTrianglePerimeter * (halfOfTrianglePerimeter - a) * (halfOfTrianglePerimeter - b) * (halfOfTrianglePerimeter - c));\r\n                    triangleHeight = 2 * triangleField / a;\r\n                    if (triangleHeight < opponentDistance) {\r\n                        tunnelValue = tunnelValue - (opponentDistance - triangleHeight);\r\n                    }\r\n                }\r\n            }\r\n            if (tunnelValue <= 0) {\r\n                tunnelValue = 0;\r\n            }\r\n        });\r\n        // console.log(destination);\r\n// console.log(\"value: \",tunnelValue,\" coordinates: \",destination.positionX,destination.positionY);\r\n        return tunnelValue;\r\n\r\n    }\r\n\r\n\r\n    getPossibilityOfPass() {\r\n        if (this.player.hasBall) {\r\n            return 0;   // diagnostics\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    getPossibilityOfShoot() {\r\n        return 0;  // diagnostics\r\n        if (this.player.hasBall) {\r\n            let field = this.player.field;\r\n            let awayGoal = {positionX: field.awayGoalX, positionY: field.awayGoalY};\r\n            let homeGoal = {positionX: field.homeGoalX, positionY: field.homeGoalY};\r\n            let distance = 0;\r\n\r\n            if (this.player.isInAwayTeam) {\r\n                distance = ((field.width / 2) - (this.player.getDistanceTo(homeGoal))) / 6;\r\n                if (distance < 0) {\r\n                    distance = 0;\r\n                }\r\n                return distance;\r\n\r\n            } else if (!this.player.isInAwayTeam) {\r\n                distance = ((field.width / 2) - (this.player.getDistanceTo(awayGoal))) / 6;\r\n                if (distance < 0) {\r\n                    distance = 0;\r\n                }\r\n                return distance;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/match/players/PlayerDecisionEvent.js b/src/match/players/PlayerDecisionEvent.js
--- a/src/match/players/PlayerDecisionEvent.js	(revision 4aeae7939184881b5c208bff5a46ee48a307d4a8)
+++ b/src/match/players/PlayerDecisionEvent.js	(date 1670428253014)
@@ -82,8 +82,8 @@
         let runningDestinations = this.getRunningDestinations(this.player, goalCenterCoordinates, r);
 
         runningDestinations.forEach((destination) => {
-            if (bestTunnelValue < this.getTunnelValue(oppositePlayers, destination)) {
-                bestTunnelValue = this.getTunnelValue(oppositePlayers, destination);
+            if (bestTunnelValue < this.getRunningTunnelValue(oppositePlayers, destination)) {
+                bestTunnelValue = this.getRunningTunnelValue(oppositePlayers, destination);
                 this.player.destinationX = destination.positionX;
                 this.player.destinationY = destination.positionY;
 
@@ -143,7 +143,7 @@
         return (radians * 180 / Math.PI);
     }
 
-    getTunnelValue(oppositePlayers, destination) {
+    getRunningTunnelValue(oppositePlayers, destination) {
         let tunnelLength = 150; // TODO - ustalić długość tunelu w zależności od skilla zawodnika
         let opponentDistance = 75; // poniżej tej wartości odległość przeciwnika od tunelu wpływa na jego ocenę
 
